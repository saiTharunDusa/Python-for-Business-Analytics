# -*- coding: utf-8 -*-
"""Welcome To Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.formula.api as smf
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix
import scipy.stats

bank_data = pd.read_csv("/content/bank_data.csv")


print(bank_data.head())
print()
print(bank_data.shape)
print()


bank_data.replace('unknown', pd.NA, inplace=True)
bank_data_updated = bank_data.dropna()
bank_data_updated.reset_index(drop=True,inplace=True)
print(bank_data_updated.count())

print()
print('The descriptive statistics are as follow: ')
print(bank_data_updated.describe())

"""**Age Distribution:**

The average age of bank clients is approximately 38.66 years, with a minimum age of 21 years and a maximum age of 94 years.
The majority of clients fall between the age range of 31 and 45 years, as indicated by the 25th percentile (31 years) and the 75th percentile (45 years).

**Job Distribution:**
The most prevalent occupation among clients is administration ("admin."), with a total of 419 occurrences.
There are a total of 11 distinct job categories, highlighting the diversity in the occupations of bank clients.

**Marital Status Distribution:**
The majority of clients are married, with a total of 848 occurrences, followed by singles and divorced/widowed clients.
There are three unique marital status categories: married, single, and unknown.

**Education Level:**
The most common education level among clients is a university degree, with a total of 528 occurrences.
There are a total of seven distinct education categories, ranging from basic education to university degrees.

**Contact Method:**
The preferred method of contact for most clients is cellular communication, with a total of 973 occurrences, compared to telephone communication.
There are two unique contact communication types: cellular and telephone.

**Month of Contact:**
The most frequent month for the last contact with clients is May, with a total of 475 occurrences, followed by other months.
There are a total of 10 unique months in which clients were last contacted.

**Day of Week of Contact:**
Thursday (Thu) appears to be the most common day of the week for the last contact, with a total of 323 occurrences.
There are five unique days of the week: Monday (Mon) to Friday (Fri).

**Subscription Status:**
The majority of clients did not subscribe to a new deposit account, with a total of 1285 occurrences of "no" compared to "yes".
"""

#create a histogram for  age distribution
plt.hist(bank_data_updated['age'],bins = 20, rwidth = 0.9)
plt.title("Distribution of Age")
plt.xlabel("Age")
plt.ylabel("Records")
plt.show()

"""The age group with the most records is between 30 and 40 years old. There are around 220 records in this group.

The number of records decreases as age increases. There are very few records of people over 65 years old.
"""

marital_counts = bank_data_updated['marital'].value_counts()

# Plotting
plt.figure(figsize=(8, 6))
marital_counts.plot(kind='bar')
plt.title('Marital Status of Bank Clients')
plt.xlabel('Marital Status')
plt.ylabel('Count')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""Married clients constitute the majority of the bank's clientele, accounting for approximately 60% of the total.
Single clients make up around 20%, while divorced clients represent approximately 10% of the client base.
"""

# Assuming your DataFrame is named 'bank_data_updated' and the columns containing marital status and subscription status are named 'marital' and 'subscribed' respectively
# Group by 'marital' and 'subscribed' columns and calculate counts
subscription_by_marital = bank_data_updated.groupby(['marital', 'subscribed']).size().reset_index(name='count')

# Filter rows with 'yes' and 'no' subscription status separately
yes_subscriptions = subscription_by_marital[subscription_by_marital['subscribed'] == 'yes']
no_subscriptions = subscription_by_marital[subscription_by_marital['subscribed'] == 'no']

# Plotting
plt.figure(figsize=(10, 6))

# Plot line for 'yes' subscription status
plt.plot(yes_subscriptions['marital'], yes_subscriptions['count'], marker='o', label='Subscribed (Yes)')

# Plot line for 'no' subscription status
plt.plot(no_subscriptions['marital'], no_subscriptions['count'], marker='o', label='Not Subscribed (No)')

# Set plot title and labels
plt.title('Subscription Status by Marital Status')
plt.xlabel('Marital Status')
plt.ylabel('Count')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.grid(True)

plt.tight_layout()
plt.show()

"""The graph shows the number of subscriptions by marital status. It appears the number of subscriptions is increasing over time for all three marital statuses: married, single, and divorced.

Married group have more subscriptions than any other group.

The rate of increase seems to be greatest for divorced customers.
"""

# Assuming your DataFrame is named 'df' and the columns containing age and campaign are named 'age' and 'campaign' respectively
# Plotting
plt.scatter(bank_data_updated['age'], bank_data_updated['job'])
plt.title('Age vs. Job type')
plt.xlabel('Age')
plt.ylabel('Job category')
plt.show()

"""Younger workers (under 30) tend to be concentrated in service jobs, student positions, and technician roles.

Meanwhile, older workers (over 50) are more likely to be found in management positions, retired, or self-employed.

"""

# Since the subscribed column is categorical.
bank_data_updated['subscribed'] = bank_data_updated['subscribed'].map({'yes': 1, 'no': 0})

# Fitting an ordinary least squares (OLS) regression model using statsmodels
model = smf.ols(formula="subscribed ~ age + education ", data=bank_data_updated).fit()

# Printing a detailed summary of the regression results
print(model.summary())

intercept = model.params[0]
basic_6y_coefficient = model.params[1]
basic_9y_coefficient = model.params[2]
high_school_coefficient = model.params[3]
illiterate_coefficient = model.params[4]
professional_course_coefficient = model.params[5]
university_degree_coefficient = model.params[6]
age_coefficient = model.params[7]

# Printing individual coefficients for interpretation
print()
print("Intercept:", intercept)
print("Basic 6y Coefficient:", basic_6y_coefficient)
print("Basic 9y Coefficient:", basic_9y_coefficient)
print("High School Coefficient:", high_school_coefficient)
print("Illiterate Coefficient:", illiterate_coefficient)
print("Professional Course Coefficient:", professional_course_coefficient)
print("University Degree Coefficient:", university_degree_coefficient)
print("Age Coefficient:", age_coefficient)


age = 40
basic_6y = 0
basic_9y = 1
high_school = 0
illiterate = 0
professional_course = 0
university_degree = 0

# Calculate the prediction
predicted_value = intercept + (age_coefficient * age) + \
                  (basic_6y_coefficient * basic_6y) + \
                  (basic_9y_coefficient * basic_9y) + \
                  (high_school_coefficient * high_school) + \
                  (illiterate_coefficient * illiterate) + \
                  (professional_course_coefficient * professional_course) + \
                  (university_degree_coefficient * university_degree)

print()
print("Predicted value:", predicted_value)
print()

"""The R-squared value of the model is extremely low at 0.011, indicating that only around 1.1% of the variance in the dependent variable (subscribed) is explained by the independent variables included in the model.

**Significance of Predictor Variables:**

Among the categorical variables representing education levels, basic.6y, basic.9y, and high.school are statistically significant at conventional levels (p < 0.05). However, illiterate, professional.course, and university.degree do not seem to be statistically significant.
The age variable also does not appear to be statistically significant, as its coefficient is very close to zero and its p-value is high (p > 0.05).

**Interpretation of Coefficients:**

The intercept represents the estimated value of subscribed when all other predictors are zero, which is 0.173 in this case.
The coefficients for the education categories represent the estimated change in subscribed compared to the baseline category when all other predictors are held constant.
For instance, individuals with a basic.6y education level are estimated to have a subscribed value approximately 0.138 lower than those in the baseline category, holding all other variables constant.
Similarly, the coefficient for age is almost zero, indicating that age has almost no effect on the subscribed variable.

**Potential Issues:**

The warning about the condition number suggests potential multicollinearity issues, where some independent variables may be highly correlated with each other, making it challenging to estimate their individual effects accurately.
The warning about standard errors assumes that the covariance matrix of the errors is correctly specified. Violating this assumption can result in biased standard errors and invalid hypothesis tests.

Predicted Value: Based on the coefficients provided, the predicted value of subscribed is approximately 0.088.
"""

model = LogisticRegression(solver="liblinear", random_state=0)
x = bank_data_updated['age'].values.reshape(-1,1)
y = bank_data_updated['subscribed'].values.reshape(-1,1)
model.fit(x, y)

# Generate the predicted probablities.
bank_data_updated['logistic_regression'] = model.predict_proba(x)[:,1]

# print the header for logistic regression
print(bank_data_updated.head())
print()

# 10 largest predicted probabilities for delayed flights
print('10 largest predicted probabilities for delayed flights:')
print(bank_data_updated.nlargest(10, 'logistic_regression'))
print()


# create a confusion matrix
the_median = bank_data_updated['logistic_regression'].median()
# create a list with value 1 if the median values are above median.
prediction = list(1 * bank_data_updated['logistic_regression'] > the_median)
# create a list with value 0 if the median values are below the median value.
actual = list(bank_data_updated['subscribed'])
print('Confusion Matrix: ')
print('[[true positives] [false positives]]')
print('[[false negatives] [true negatives]]')
conf_mat = confusion_matrix(prediction, actual)
print()
print(conf_mat)

# calculate the accuracy scores based on the generated confusion matrix.
# Precision - How many actually positive out of what we thought would be positive
# Recall (sensitivity) - From the true positive cases, how many did we think were positive

print()
precision = conf_mat[0][0] /(conf_mat[0][0] + conf_mat[0][1])
print(f"Precision: {precision}")
print()
recall = conf_mat[0][0] /(conf_mat[0][0] + conf_mat[1][0])
print(f"Recall : {recall}")
print()

# [[true positives] [false positives]]
# [[false negatives] [true negatives]]

# [[688  83]
#  [597  99]]

"""**Precision:** The precision is calculated to be approximately 89.23%, indicating that around 89.23% of the positive predictions made by the model are accurate.

Recall (Sensitivity): **bold text** The recall is approximately 53.54%, showing that the model correctly identifies about 53.54% of the actual positive cases.

The model correctly predicted 688 instances of clients not subscribing to the deposit account.
However, it incorrectly predicted 83 instances as subscribing when they did not.
The model missed predicting 597 instances of clients who actually subscribed to the deposit account.
It correctly predicted 99 instances of clients subscribing to the deposit account.
"""

bank_data_updated_married = bank_data_updated[bank_data_updated['marital'] == 'married']['subscribed'].map({'yes': 1, 'no': 0})
bank_data_updated_single = bank_data_updated[bank_data_updated['marital'] == 'single']['subscribed'].map({'yes': 1, 'no': 0})


print('For Subscribed:')
print('H0: There is no significant difference between the count for subscribed,\n'
 ' for married compared to single')
print()
print('H1: There is a significant difference between the count for the subscribed,\n'
 ' for married compared to single ')
print()

# Conduct t-test
print('T-test results for difference between the count for the subscribed,\n'
 'for married compared to single ')
print(scipy.stats.ttest_ind(bank_data_updated_married, bank_data_updated_single))
print()
print('Since the p-value for number of teens is lesser than 0.05, we reject the null hypothesis\n'
'and conclude that there is significant difference between the count for subscribed,\n'
 ' for married compared to single')